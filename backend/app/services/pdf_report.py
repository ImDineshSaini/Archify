"""Comprehensive PDF report generation for code analysis results.

Generates a full report matching all data visible in the UI tabs:
- Executive Summary (scores, grade)
- Code Quality Metrics (lines, files, functions, classes, complexity)
- Architecture & Patterns
- Deep Analysis — all 5 layers with ALL issues + recommendations
- Synthesis Report — executive summary, all priority levels, quick wins
- NFR Analysis — category scores, recommendations
- AI Suggestions
"""

import io
import re
from datetime import datetime, timezone
from typing import Any, Dict

from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    HRFlowable,
    PageBreak,
)


def generate_analysis_pdf(
    analysis: Dict[str, Any],
    repo_name: str = "Repository",
    repo_url: str = "",
) -> bytes:
    """Generate a comprehensive PDF report from analysis data. Returns PDF bytes."""
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(
        buffer,
        pagesize=A4,
        rightMargin=40,
        leftMargin=40,
        topMargin=40,
        bottomMargin=40,
    )

    styles = _build_styles()
    elements = []

    # Normalize repo_url for building file links
    repo_url = _normalize_repo_url(repo_url)

    detailed_report = analysis.get("detailed_report") or {}
    deep_analysis = detailed_report.get("deep_analysis") or {}

    # ── Cover / Title ───────────────────────────────────────────────────
    _add_title(elements, styles, analysis, repo_name, repo_url)

    # ── 1. Executive Summary — Scores ───────────────────────────────────
    _add_scores_section(elements, styles, analysis)

    # ── 2. Code Quality Metrics ─────────────────────────────────────────
    _add_code_metrics_section(elements, styles, analysis, detailed_report)

    # ── 3. Architecture & Patterns ──────────────────────────────────────
    _add_architecture_section(elements, styles, detailed_report)

    # ── 4. Deep Analysis — Synthesis Report ─────────────────────────────
    synthesis = deep_analysis.get("synthesis") or {}
    if synthesis and not synthesis.get("error"):
        _add_synthesis_section(elements, styles, synthesis, repo_url)

    # ── 5. Deep Analysis — All 5 Layer Reports ──────────────────────────
    layers = deep_analysis.get("layers") or {}
    if layers:
        _add_layers_section(elements, styles, layers, repo_url)

    # ── 6. NFR Analysis ─────────────────────────────────────────────────
    nfr_analysis = detailed_report.get("nfr_analysis")
    if nfr_analysis:
        _add_nfr_section(elements, styles, nfr_analysis)

    # ── 7. AI Suggestions ───────────────────────────────────────────────
    suggestions = analysis.get("suggestions")
    if suggestions:
        _add_suggestions_section(elements, styles, suggestions)

    # ── 8. Issues (complexity warnings) ─────────────────────────────────
    issues = analysis.get("issues")
    if issues:
        _add_issues_section(elements, styles, issues, repo_url)

    # ── Footer ──────────────────────────────────────────────────────────
    elements.append(Spacer(1, 20))
    elements.append(HRFlowable(width="100%", thickness=1, color=colors.HexColor("#283593")))
    elements.append(Spacer(1, 6))
    elements.append(Paragraph(
        f"Generated by <b>Archify</b> — Code Analysis Platform | {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}",
        styles["small"],
    ))

    doc.build(elements)
    return buffer.getvalue()


# ════════════════════════════════════════════════════════════════════════════
# Section builders
# ════════════════════════════════════════════════════════════════════════════

def _add_title(elements, styles, analysis, repo_name, repo_url):
    elements.append(Paragraph("Code Analysis Report", styles["title"]))
    elements.append(Spacer(1, 4))
    if repo_url:
        elements.append(Paragraph(
            f'Repository: <b><a href="{_esc(repo_url)}" color="#1565c0">{_esc(repo_name)}</a></b>',
            styles["body"],
        ))
    else:
        elements.append(Paragraph(f"Repository: <b>{_esc(repo_name)}</b>", styles["body"]))
    duration = analysis.get("analysis_duration")
    if duration:
        elements.append(Paragraph(f"Analysis Duration: {duration:.1f}s", styles["small"]))
    elements.append(Spacer(1, 12))


def _add_scores_section(elements, styles, analysis):
    elements.append(Paragraph("1. Executive Summary — Quality Scores", styles["h1"]))

    score_items = [
        ("Overall Score", analysis.get("overall_score")),
        ("Maintainability", analysis.get("maintainability_score")),
        ("Reliability", analysis.get("reliability_score")),
        ("Security", analysis.get("security_score")),
        ("Scalability", analysis.get("scalability_score")),
    ]

    data = [["Metric", "Score", "Grade"]]
    for name, score in score_items:
        if score is not None:
            grade = _score_grade(score)
            data.append([name, f"{score:.1f}/100", grade])
        else:
            data.append([name, "N/A", "-"])

    table = Table(data, colWidths=[3 * inch, 1.5 * inch, 1.5 * inch])
    table.setStyle(_table_style_header("#283593"))
    elements.append(table)
    elements.append(Spacer(1, 12))


def _add_code_metrics_section(elements, styles, analysis, detailed_report):
    elements.append(Paragraph("2. Code Quality Metrics", styles["h1"]))

    # Try code_metrics from analysis first, then from detailed_report
    cm_data = analysis.get("code_metrics") or detailed_report.get("code_metrics") or {}

    if not cm_data:
        elements.append(Paragraph("No code metrics data available.", styles["body"]))
        elements.append(Spacer(1, 8))
        return

    metrics_items = [
        ("Total Lines", cm_data.get("total_lines", 0)),
        ("Code Lines", cm_data.get("code_lines", 0)),
        ("Comment Lines", cm_data.get("comment_lines", 0)),
        ("Blank Lines", cm_data.get("blank_lines", 0)),
        ("Files Analyzed", cm_data.get("files_analyzed", 0)),
        ("Functions", cm_data.get("functions", "N/A")),
        ("Classes", cm_data.get("classes", "N/A")),
    ]

    total = cm_data.get("total_lines", 0)
    comments = cm_data.get("comment_lines", 0)
    if total > 0:
        metrics_items.append(("Comment Ratio", f"{(comments / total) * 100:.1f}%"))

    avg_complexity = cm_data.get("avg_complexity")
    if avg_complexity is not None:
        metrics_items.append(("Avg Complexity", f"{avg_complexity:.1f}"))

    data = [["Metric", "Value"]]
    for name, val in metrics_items:
        data.append([name, str(val) if val is not None else "N/A"])

    table = Table(data, colWidths=[3 * inch, 3 * inch])
    table.setStyle(_table_style_header("#37474f"))
    elements.append(table)

    # Languages breakdown
    languages = cm_data.get("languages", {})
    if languages:
        elements.append(Spacer(1, 6))
        elements.append(Paragraph("<b>Languages:</b> " + ", ".join(
            f"{lang} ({count} files)" for lang, count in sorted(languages.items(), key=lambda x: -x[1])
        ), styles["body"]))

    elements.append(Spacer(1, 12))


def _add_architecture_section(elements, styles, detailed_report):
    arch = detailed_report.get("architecture") or {}
    if not arch:
        return

    elements.append(Paragraph("3. Architecture & Patterns", styles["h1"]))

    info_lines = []
    if arch.get("language"):
        info_lines.append(f"<b>Primary Language:</b> {_esc(arch['language'])}")
    if arch.get("project_type"):
        info_lines.append(f"<b>Project Type:</b> {_esc(arch['project_type'])}")
    if arch.get("frameworks"):
        info_lines.append(f"<b>Frameworks:</b> {_esc(', '.join(arch['frameworks']))}")
    if arch.get("detected_patterns"):
        info_lines.append(f"<b>Detected Patterns:</b> {_esc(', '.join(arch['detected_patterns']))}")
    if arch.get("design_patterns"):
        info_lines.append(f"<b>Design Patterns:</b> {_esc(', '.join(arch['design_patterns']))}")

    for line in info_lines:
        elements.append(Paragraph(line, styles["body"]))

    elements.append(Spacer(1, 12))


def _add_synthesis_section(elements, styles, synthesis, repo_url):
    elements.append(PageBreak())
    elements.append(Paragraph("4. Synthesis Report", styles["h1"]))

    # Executive Summary
    if synthesis.get("executive_summary"):
        elements.append(Paragraph("<b>Executive Summary</b>", styles["h2"]))
        elements.append(Paragraph(_esc(synthesis["executive_summary"]), styles["body"]))
        elements.append(Spacer(1, 8))

    # Priority sections — ALL issues, not truncated
    priority_sections = [
        ("Critical Issues — Fix Immediately", synthesis.get("critical_issues", []), "#d32f2f"),
        ("High Priority — 1-2 Sprints", synthesis.get("high_priority", []), "#f57c00"),
        ("Medium Priority — 1-2 Months", synthesis.get("medium_priority", []), "#1976d2"),
        ("Low Priority — Nice to Have", synthesis.get("low_priority", []), "#388e3c"),
    ]

    for section_name, issues, color in priority_sections:
        if not issues:
            continue
        elements.append(Paragraph(
            f"<font color='{color}'><b>{section_name} ({len(issues)})</b></font>",
            styles["h2"],
        ))
        for i, issue in enumerate(issues, 1):
            _add_issue_block(elements, styles, issue, i, repo_url)
        elements.append(Spacer(1, 6))

    # Quick Wins
    quick_wins = synthesis.get("quick_wins", [])
    if quick_wins:
        elements.append(Paragraph("<b>Quick Wins (under 4 hours each)</b>", styles["h2"]))
        for i, win in enumerate(quick_wins, 1):
            elements.append(Paragraph(f"{i}. {_esc(str(win))}", styles["body"]))
        elements.append(Spacer(1, 6))

    # Effort estimate
    effort = synthesis.get("estimated_total_effort_days")
    if effort:
        elements.append(Paragraph(
            f"<b>Estimated Total Effort: {effort} days</b>", styles["h2"],
        ))
    elements.append(Spacer(1, 8))


def _add_layers_section(elements, styles, layers, repo_url):
    elements.append(PageBreak())
    elements.append(Paragraph("5. Deep Analysis — Layer Details", styles["h1"]))

    layer_config = {
        "security": ("Security Analysis", "critical_issues"),
        "performance": ("Performance Analysis", "bottlenecks"),
        "testing": ("Testing Analysis", "coverage_gaps"),
        "devops": ("DevOps Analysis", "missing_devops"),
        "code_quality": ("Code Quality Analysis", "quality_issues"),
    }

    for layer_key, (display_name, issues_key) in layer_config.items():
        layer_data = layers.get(layer_key, {})
        if not layer_data or layer_data.get("error"):
            continue

        issues = layer_data.get(issues_key, [])
        recommendations = layer_data.get("recommendations", [])

        if not issues and not recommendations:
            continue

        elements.append(HRFlowable(width="100%", thickness=1, color=colors.HexColor("#283593")))
        elements.append(Spacer(1, 4))
        elements.append(Paragraph(f"{display_name}", styles["h2"]))

        # ALL issues — no limit
        if issues:
            elements.append(Paragraph(f"<b>Issues Found: {len(issues)}</b>", styles["body_bold"]))
            for i, issue in enumerate(issues, 1):
                _add_layer_issue_block(elements, styles, issue, i, repo_url)
            elements.append(Spacer(1, 4))

        # ALL recommendations — no limit
        if recommendations:
            elements.append(Paragraph("<b>Recommendations:</b>", styles["body_bold"]))
            for i, rec in enumerate(recommendations, 1):
                elements.append(Paragraph(f"{i}. {_esc(str(rec))}", styles["body"]))
            elements.append(Spacer(1, 8))


def _add_nfr_section(elements, styles, nfr_analysis):
    elements.append(PageBreak())
    elements.append(Paragraph("6. Non-Functional Requirements (NFR) Analysis", styles["h1"]))

    # Category averages
    cat_avgs = nfr_analysis.get("category_averages", {})
    if cat_avgs:
        elements.append(Paragraph("<b>Category Scores</b>", styles["h2"]))
        data = [["Category", "Score"]]
        for cat, score in sorted(cat_avgs.items(), key=lambda x: -x[1]):
            data.append([cat, f"{score:.1f}/100"])
        table = Table(data, colWidths=[4 * inch, 2 * inch])
        table.setStyle(_table_style_header("#37474f"))
        elements.append(table)
        elements.append(Spacer(1, 8))

    # All individual NFR scores
    nfr_scores = nfr_analysis.get("nfr_scores", {})
    if nfr_scores:
        elements.append(Paragraph("<b>All NFR Attribute Scores</b>", styles["h2"]))

        # Group by category if available
        categories = nfr_analysis.get("nfr_categories", {})
        if categories:
            for cat_name, attrs in sorted(categories.items()):
                elements.append(Paragraph(f"<i>{_esc(cat_name)}</i>", styles["body_bold"]))
                data = [["Attribute", "Score"]]
                for attr in sorted(attrs):
                    score = nfr_scores.get(attr, 0)
                    data.append([attr.replace("_", " ").title(), f"{score:.0f}"])
                table = Table(data, colWidths=[4 * inch, 2 * inch])
                table.setStyle(_table_style_header("#546e7a"))
                elements.append(table)
                elements.append(Spacer(1, 4))
        else:
            data = [["Attribute", "Score"]]
            for attr, score in sorted(nfr_scores.items(), key=lambda x: -x[1]):
                data.append([attr.replace("_", " ").title(), f"{score:.0f}"])
            table = Table(data, colWidths=[4 * inch, 2 * inch])
            table.setStyle(_table_style_header("#546e7a"))
            elements.append(table)

        elements.append(Spacer(1, 8))

    # NFR recommendations
    recommendations = nfr_analysis.get("recommendations", [])
    if recommendations:
        elements.append(Paragraph("<b>NFR Recommendations</b>", styles["h2"]))
        for rec in recommendations:
            if isinstance(rec, dict):
                priority = rec.get("priority", "")
                attr = rec.get("attribute", "")
                text = rec.get("recommendation", "")
                impact = rec.get("impact", "")
                prefix = f"[{priority}] " if priority else ""
                attr_text = f"<b>{_esc(attr)}</b>: " if attr else ""
                elements.append(Paragraph(
                    f"{prefix}{attr_text}{_esc(text)}", styles["body"],
                ))
                if impact:
                    elements.append(Paragraph(
                        f"&nbsp;&nbsp;&nbsp;<i>Impact: {_esc(impact)}</i>", styles["small"],
                    ))
            else:
                elements.append(Paragraph(f"- {_esc(str(rec))}", styles["body"]))
        elements.append(Spacer(1, 8))


def _add_suggestions_section(elements, styles, suggestions):
    elements.append(PageBreak())
    elements.append(Paragraph("7. AI-Powered Suggestions", styles["h1"]))

    if isinstance(suggestions, str):
        _render_markdown_text(elements, styles, suggestions)
    else:
        elements.append(Paragraph(_esc(str(suggestions)), styles["body"]))

    elements.append(Spacer(1, 8))


def _add_issues_section(elements, styles, issues, repo_url):
    if not issues:
        return
    elements.append(Paragraph("8. Code Issues & Warnings", styles["h1"]))

    for i, issue in enumerate(issues, 1):
        if isinstance(issue, dict):
            severity = issue.get("severity", "")
            issue_type = issue.get("type", "")
            message = issue.get("message", str(issue))
            prefix = f"[{severity.upper()}] " if severity else ""
            type_tag = f"({issue_type}) " if issue_type else ""
            elements.append(Paragraph(
                f"<b>{i}. {_esc(prefix)}{_esc(type_tag)}</b>{_esc(message)}",
                styles["body"],
            ))
            # Show details with linked location
            details = issue.get("details", {})
            if isinstance(details, dict):
                loc = details.get("file", details.get("location", ""))
                if loc:
                    elements.append(Paragraph(
                        f"&nbsp;&nbsp;&nbsp;Location: {_format_location(loc, repo_url)}",
                        styles["small"],
                    ))
        else:
            elements.append(Paragraph(f"{i}. {_esc(str(issue))}", styles["body"]))

    elements.append(Spacer(1, 8))


# ════════════════════════════════════════════════════════════════════════════
# Issue block helpers
# ════════════════════════════════════════════════════════════════════════════

def _add_issue_block(elements, styles, issue, index, repo_url):
    """Render a synthesis issue with all detail fields."""
    if isinstance(issue, dict):
        text = issue.get("issue", issue.get("gap", str(issue)))
        elements.append(Paragraph(f"<b>{index}. {_esc(text)}</b>", styles["body"]))

        details = []
        if issue.get("location"):
            details.append(f"Location: {_format_location(issue['location'], repo_url)}")
        if issue.get("category"):
            details.append(f"Category: {_esc(issue['category'])}")
        if issue.get("fix"):
            details.append(f"Fix: {_esc(issue['fix'])}")
        if issue.get("effort_hours"):
            details.append(f"Effort: {issue['effort_hours']} hours")
        if issue.get("business_impact"):
            details.append(f"Business Impact: {_esc(issue['business_impact'])}")
        if issue.get("dependencies"):
            deps = issue["dependencies"]
            if isinstance(deps, list) and deps:
                details.append(f"Dependencies: {_esc(', '.join(str(d) for d in deps))}")

        for detail in details:
            elements.append(Paragraph(f"&nbsp;&nbsp;&nbsp;{detail}", styles["small"]))
    else:
        elements.append(Paragraph(f"{index}. {_esc(str(issue))}", styles["body"]))


def _add_layer_issue_block(elements, styles, issue, index, repo_url):
    """Render a layer-specific issue with all fields visible in IssueCard."""
    if isinstance(issue, dict):
        # Pick the right title field depending on layer
        text = (
            issue.get("issue")
            or issue.get("gap")
            or issue.get("missing_tests_for")
            or str(issue)
        )
        priority = issue.get("priority", issue.get("risk_level", ""))
        prefix = f"[{priority}] " if priority else ""
        elements.append(Paragraph(f"<b>{index}. {_esc(prefix)}{_esc(text)}</b>", styles["body"]))

        details = []
        if issue.get("location"):
            details.append(f"Location: {_format_location(issue['location'], repo_url)}")
        if issue.get("evidence"):
            details.append(f"Evidence: {_esc(issue['evidence'])}")
        if issue.get("fix"):
            details.append(f"Fix: {_esc(issue['fix'])}")
        if issue.get("refactoring"):
            details.append(f"Refactoring: {_esc(issue['refactoring'])}")
        if issue.get("expected_improvement"):
            details.append(f"Expected Improvement: {_esc(issue['expected_improvement'])}")
        if issue.get("impact"):
            details.append(f"Impact: {_esc(issue['impact'])}")
        if issue.get("test_type"):
            details.append(f"Test Type: {_esc(issue['test_type'])}")

        for detail in details:
            elements.append(Paragraph(f"&nbsp;&nbsp;&nbsp;{detail}", styles["small"]))
    else:
        elements.append(Paragraph(f"{index}. {_esc(str(issue))}", styles["body"]))


# ════════════════════════════════════════════════════════════════════════════
# Location → repo URL linking
# ════════════════════════════════════════════════════════════════════════════

# Pattern to match local temp clone dir names like "archify_repo_kdn16j6y/"
_TEMP_DIR_PATTERN = re.compile(r'^/?(?:archify_repo_\w+|/tmp/[^/]+)/?')


def _normalize_repo_url(url: str) -> str:
    """Normalize a GitHub/GitLab repo URL to a base suitable for file linking."""
    if not url:
        return ""
    url = url.rstrip("/")
    # Strip .git suffix
    if url.endswith(".git"):
        url = url[:-4]
    return url


def _build_file_url(file_path: str, repo_url: str) -> str:
    """Build a full GitHub/GitLab file URL from a relative path."""
    if not repo_url or not file_path:
        return ""
    # Clean the path: strip local temp dir prefix
    clean_path = _TEMP_DIR_PATTERN.sub("", file_path)
    clean_path = clean_path.lstrip("/")
    if not clean_path:
        return repo_url
    # GitHub uses /blob/main/, GitLab uses /-/blob/main/
    if "gitlab" in repo_url.lower():
        return f"{repo_url}/-/blob/main/{clean_path}"
    return f"{repo_url}/blob/main/{clean_path}"


def _format_location(location: str, repo_url: str) -> str:
    """Format a location string as a clickable hyperlink if repo_url is available.

    Returns ReportLab XML markup (already escaped).
    Handles:
    - Single file path: "src/index.html"
    - Path with local temp prefix: "archify_repo_abc123/src/index.html"
    - Multiple paths separated by comma: "src/a.py, src/b.py"
    - Directory references: "src/controllers/"
    """
    if not location:
        return ""

    if not repo_url:
        return f"<font color='#d32f2f'>{_esc(location)}</font>"

    # Split by comma for multiple locations
    parts = [p.strip() for p in location.split(",")]
    linked_parts = []

    for part in parts:
        if not part:
            continue
        file_url = _build_file_url(part, repo_url)
        # Clean the display text too (strip temp dir prefix)
        display = _TEMP_DIR_PATTERN.sub("", part).lstrip("/") or part
        if file_url:
            linked_parts.append(
                f'<a href="{_esc(file_url)}" color="#1565c0">{_esc(display)}</a>'
            )
        else:
            linked_parts.append(f"<font color='#d32f2f'>{_esc(display)}</font>")

    return ", ".join(linked_parts)


# ════════════════════════════════════════════════════════════════════════════
# Markdown → ReportLab converter
# ════════════════════════════════════════════════════════════════════════════

def _render_markdown_text(elements, styles, text: str):
    """Convert markdown text into ReportLab paragraphs with proper formatting.

    Handles: headers, bold, italic, links, bullet points, numbered lists.
    """
    lines = text.split('\n')
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped = line.strip()

        # Empty line → spacer
        if not stripped:
            elements.append(Spacer(1, 4))
            i += 1
            continue

        # Markdown headers: ### Header, ## Header, # Header
        if stripped.startswith('#'):
            match = re.match(r'^(#{1,3})\s+(.*)', stripped)
            if match:
                level = len(match.group(1))
                header_text = match.group(2).strip()
                header_text = _md_inline_to_xml(header_text)
                if level == 1:
                    elements.append(Paragraph(f"<b>{header_text}</b>", styles["h2"]))
                elif level == 2:
                    elements.append(Paragraph(f"<b>{header_text}</b>", styles["body_bold"]))
                else:
                    elements.append(Paragraph(f"<b>{header_text}</b>", styles["body_bold"]))
                i += 1
                continue

        # Section headers: **[High] Title** or **Title**
        if stripped.startswith('**') and stripped.endswith('**') and stripped.count('**') == 2:
            header_text = stripped[2:-2]
            elements.append(Spacer(1, 6))
            elements.append(Paragraph(f"<b>{_esc(header_text)}</b>", styles["body_bold"]))
            i += 1
            continue

        # Bullet points: - text or * text
        if re.match(r'^[-*]\s+', stripped):
            bullet_text = re.sub(r'^[-*]\s+', '', stripped)
            bullet_text = _md_inline_to_xml(bullet_text)
            elements.append(Paragraph(f"&nbsp;&nbsp;&bull;&nbsp;{bullet_text}", styles["body"]))
            i += 1
            continue

        # Numbered list: 1. text, 2. text
        num_match = re.match(r'^(\d+)\.\s+(.*)', stripped)
        if num_match:
            num = num_match.group(1)
            item_text = _md_inline_to_xml(num_match.group(2))
            elements.append(Paragraph(f"&nbsp;&nbsp;{num}. {item_text}", styles["body"]))
            i += 1
            continue

        # Regular paragraph text — convert inline markdown
        para_text = _md_inline_to_xml(stripped)
        elements.append(Paragraph(para_text, styles["body"]))
        i += 1


def _md_inline_to_xml(text: str) -> str:
    """Convert inline markdown formatting to ReportLab XML tags.

    Handles: **bold**, *italic*, [link text](url), `code`
    """
    # First escape the text for XML
    text = _esc(text)

    # Bold: **text** → <b>text</b>
    text = re.sub(r'\*\*(.+?)\*\*', r'<b>\1</b>', text)

    # Italic: *text* → <i>text</i>  (but not ** which is already handled)
    text = re.sub(r'(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)', r'<i>\1</i>', text)

    # Links: [text](url) → <a href="url" color="#1565c0">text</a>
    text = re.sub(
        r'\[([^\]]+)\]\(([^)]+)\)',
        r'<a href="\2" color="#1565c0">\1</a>',
        text,
    )

    # Inline code: `code` → <font face="Courier" size="8">code</font>
    text = re.sub(r'`([^`]+)`', r'<font face="Courier" size="8">\1</font>', text)

    return text


# ════════════════════════════════════════════════════════════════════════════
# Shared helpers
# ════════════════════════════════════════════════════════════════════════════

def _build_styles():
    base = getSampleStyleSheet()
    return {
        "title": ParagraphStyle("RPT_Title", parent=base["Title"], fontSize=24, spaceAfter=6,
                                textColor=colors.HexColor("#1a237e")),
        "h1": ParagraphStyle("RPT_H1", parent=base["Heading1"], fontSize=16, spaceBefore=16,
                             spaceAfter=8, textColor=colors.HexColor("#283593")),
        "h2": ParagraphStyle("RPT_H2", parent=base["Heading2"], fontSize=12, spaceBefore=10,
                             spaceAfter=4, textColor=colors.HexColor("#37474f")),
        "body": ParagraphStyle("RPT_Body", parent=base["Normal"], fontSize=9, spaceAfter=3,
                               leading=13),
        "body_bold": ParagraphStyle("RPT_BodyBold", parent=base["Normal"], fontSize=9,
                                    spaceAfter=3, leading=13, fontName="Helvetica-Bold"),
        "small": ParagraphStyle("RPT_Small", parent=base["Normal"], fontSize=8, spaceAfter=2,
                                textColor=colors.HexColor("#616161"), leading=11),
    }


def _table_style_header(header_color: str) -> TableStyle:
    return TableStyle([
        ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor(header_color)),
        ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
        ("FONTSIZE", (0, 0), (-1, 0), 9),
        ("FONTSIZE", (0, 1), (-1, -1), 8),
        ("ALIGN", (1, 0), (-1, -1), "CENTER"),
        ("GRID", (0, 0), (-1, -1), 0.5, colors.HexColor("#bdbdbd")),
        ("ROWBACKGROUNDS", (0, 1), (-1, -1), [colors.white, colors.HexColor("#f5f5f5")]),
        ("TOPPADDING", (0, 0), (-1, -1), 5),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 5),
        ("LEFTPADDING", (0, 0), (-1, -1), 6),
        ("VALIGN", (0, 0), (-1, -1), "TOP"),
    ])


def _score_grade(score: float) -> str:
    if score >= 90: return "A+"
    if score >= 80: return "A"
    if score >= 70: return "B"
    if score >= 60: return "C"
    if score >= 50: return "D"
    return "F"


def _esc(text: str) -> str:
    """Escape text for ReportLab XML markup."""
    if not isinstance(text, str):
        text = str(text)
    return (
        text
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )
